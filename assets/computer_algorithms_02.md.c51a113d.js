import{_ as a,c as s,o as e,N as n}from"./chunks/framework.af04725e.js";const t="/blog/assets/4.056d7279.webp",r="/blog/assets/5.4abc22d2.webp",g=JSON.parse('{"title":"数组","description":"","frontmatter":{},"headers":[],"relativePath":"computer/algorithms/02.md"}'),o={name:"computer/algorithms/02.md"},l=n('<h1 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h1><blockquote><p><strong>数组（Array）<strong>是一种</strong>线性表</strong>数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p></blockquote><h3 id="线性表-linear-list" tabindex="-1">线性表 （Linear List） <a class="header-anchor" href="#线性表-linear-list" aria-label="Permalink to &quot;线性表 （Linear List）&quot;">​</a></h3><p>顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了<strong>数组，链表、队列、栈</strong>等也是线性表结构。</p><p><img src="'+t+'" alt="线性表"></p><h3 id="非线性表" tabindex="-1">非线性表 <a class="header-anchor" href="#非线性表" aria-label="Permalink to &quot;非线性表&quot;">​</a></h3><p>比如<strong>二叉树、堆、图</strong>等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><p><img src="'+r+`" alt="非线性表"></p><h3 id="随机访问" tabindex="-1">随机访问 <a class="header-anchor" href="#随机访问" aria-label="Permalink to &quot;随机访问&quot;">​</a></h3><p>数组是连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><p>我在面试的时候，常常会问数组和链表的区别，很多人都回答说，“<strong>链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)</strong>”。</p><p>实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，<strong>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</strong>。</p><h3 id="低效的-插入-和-删除" tabindex="-1">低效的“插入”和“删除” <a class="header-anchor" href="#低效的-插入-和-删除" aria-label="Permalink to &quot;低效的“插入”和“删除”&quot;">​</a></h3><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？ 从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">a[k]_address = base_address + k * type_size</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">a[k]_address = base_address + (k-1)*type_size</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p>`,19),i=[l];function p(c,d,h,_,b,u){return e(),s("div",null,i)}const k=a(o,[["render",p]]);export{g as __pageData,k as default};
